# 第五章-创建高性能索引

### 索引基础
* MySQL只能高效的使用索引的最左前缀列。


## 1.索引类型
### B-Tree

* 注意 ： 以下匹配解释基于索引： key(last_name,first_name,dob)。
---
 B-TREE匹配模式|   B-TREE匹配模式解释
--- | ---
全值匹配 | 指和索引中所有的对应列匹配(如：last_name= allen, first_name = tom,dob = 1991-01-01)
匹配最左前缀 | 前面提到的索引可以用于查询 last_name = allen 的人，即只使用索引的第一列
匹配前缀列 | 匹配索引某一列
匹配范围值 | 匹配索引的某个范围（如：Allen 和 bob之间的人）
精确匹配某一列，范围匹配另一列 | 即：last_name 全匹配，first_name部分匹配
只访问索引的查询 | 查询只需访问索引无需访问数据行

### B-Tree 限制
* 如果不是按照索引的最左列开始查找，则无法使用索引
* 不能跳过索引的列
* 如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引
---
### Hash 索引
* 以下匹配解释基于索引： key(last_name)
---
* 哈希索引只包含哈希值和行指针，而不能使用索引中的值来 避免行读取。
* 哈希索引数据无序，无法用于排序
* 哈希索引同样不支持部分索引列匹配查找（索引是使用索引列的全部内容来计算索引）
* 哈希索引只支持等值比较。
* 哈希索引的数据非常快，若出现很多的hash冲突，维护的索引代价同样也会很高。
* InnoDB 有“自适应哈希索引”，当一些索引使用的非常频繁，在内存中基于BTree索引之上会创建哈希索引
* 创建自定义的哈希索引，一些字符串查找使用哈希值作为索引查找会大大增高性能。
## 2. 索引的优点
* 索引大大减少了服务器需要扫描的数据量
* 索引可以帮助服务器避免排序和临时表
* 索引可以将随机I/O变为顺序I/O

## 3. 高性能的索引策略
### 独立的列
* 若查询中的列不是独立，则MySQL就不会使用索引。独立：是指索引列不能是表达式的一部分，也不能是函数的参数。（如：select * from T where id + 1 = 5, 这里其实id = 4，但是MySQL无法解析这个方程。无法使用索引）
### 前缀索引和索引选择性
* 对于一些很长的varchar列，无法对完整列创建索引，选择合适长度的前缀作为前缀列作为索引，提高查询速度。（合适的前缀列是指：前缀列的选择性接近完整列的选择性）
### 多列索引
* 对多个索引列进行查询，MySQL会使用“索引合并”的策略，即同时使用单列的索引进行扫描，将结果合并，这种算法有三个变种：
* OR条件 的 联合
* AND条件 的 相交
* 组合前2种情况的联合及相交

